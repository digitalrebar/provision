package models

import (
	"crypto/ed25519"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"os"
	"path"
	"strconv"
	"time"

	"github.com/pborman/uuid"
)

// Cert is one of the self-signed root CA entries used to secure communication between
// consensus cluster members.  Members will trust any key signed with one of these.
type Cert struct {
	Data [][]byte
	Key  ed25519.PrivateKey
	leaf *tls.Certificate
}

func (c *Cert) setTls() error {
	leaf, err := x509.ParseCertificate(c.Data[0])
	if err != nil {
		return err
	}
	c.leaf = &tls.Certificate{
		Certificate: c.Data,
		PrivateKey:  c.Key,
		Leaf:        leaf,
	}
	return nil
}

// TLS converts the Cert into a TLS compatible certificate.
func (c *Cert) TLS() *tls.Certificate {
	if c.leaf == nil {
		log.Panicf("cert TLS called with nil leaf!")
	}
	return c.leaf
}

// GlobalHaState is the consensus state shared by all members of
// a consensus cluster.
type GlobalHaState struct {
	// LoadBalanced indicates that an external service is responsible for
	// routing traffic destined to VirtAddr to a cluster node.
	LoadBalanced bool
	// Enabled indicates whether either HA mode is operating on this cluster.
	// If just Enabled is set, the cluster is using the synchronous replication
	// protocol with manual failover.
	Enabled bool
	// ConsensusEnabled indicates that this cluster is operating on the Raft
	// based replication protocol with automatic failover.
	ConsensusEnabled bool
	// ConsensusJoin is the API URL of the current active node in a consensus
	// cluster.  It may be unset if the cluster nodes cannot agree who should
	// be the active node, or if the cluster is operating using the sync replication
	// protocol.
	ConsensusJoin string
	// VirtAddr is the IP address that the cluster should appear to have from the
	// perspective of clients and third parties.
	VirtAddr string
	// ActiveUri is the API URL of cthe cluster as built from the virtual addr.
	ActiveUri string
	// Token is an API authentication token that can be sued to perform cluster operations.
	Token string
	// HaID is the ID of the cluster as a whole.
	HaID string
	// Valid indicates that this state is valid and has been consistency checked.
	Valid bool
	// Roots is a list of self-signed trust roots that consensus nodes will use
	// to verify communication.  These roots are automatically created and rotated
	// on a regular basis.
	Roots []Cert
}

func (g *GlobalHaState) FillTls() error {
	for i := range g.Roots {
		if err := (&g.Roots[i]).setTls(); err != nil {
			return err
		}
	}
	return nil
}

// NodeHaState tracks the HA state for an individual node.
type NodeHaState struct {
	// ConsensusID us the unique autogenerated ID for this node.
	// Once set, it must not be changed, or else other nodes in
	// a cluster will not recognize this node.
	ConsensusID uuid.UUID
	// VirtInterface is the network interface that the global VirtAddr
	// will be added on when this node si the active node, and removed from
	// when this node is no longer the active node.
	VirtInterface string
	// VirtInterfaceScript will be called whenever VirtAddr must be added
	// or removed from VirtInterface.  If empty, a default set of scripts
	// will be sued that are appropriate to the OS type dr-provision is running on.
	VirtInterfaceScript string
	// ConsensusAddr is the addr:port that other nodes should attempt to contact
	// this node no when operating in consensus mode.  All communication over these
	// ports will be secured using TLS 1.3 using per-node short-lived certs signed
	// by the certs in the global Roots field.
	ConsensusAddr string
	// ApiUrl is the URL that can be used to contact this node's API directly.
	ApiUrl string
	// Passive indicates that this node is not responsible for handling client connections
	// or writes via the API.
	Passive bool
	// Observer indicates that this node cannot become the active node.  It is used when
	// a node should act as a live backup and a consensus tiebreaker.
	Observer bool
}

// CurrentHAState is the GlobalHaState and the NodeHaState for a particular node.
type CurrentHAState struct {
	GlobalHaState
	NodeHaState
}

func makeCert(template *x509.Certificate, parentCert *tls.Certificate) (*tls.Certificate, error) {
	var err error
	var priv ed25519.PrivateKey
	var public ed25519.PublicKey
	public, priv, err = ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, err
	}
	var parent *x509.Certificate
	var parentPriv ed25519.PrivateKey
	if parentCert == nil {
		parent = template
		parentPriv = priv
	} else {
		parent = parentCert.Leaf
		parentPriv = parentCert.PrivateKey.(ed25519.PrivateKey)
	}
	var derBytes []byte
	derBytes, err = x509.CreateCertificate(rand.Reader, template, parent, public, parentPriv)
	if err != nil {
		return nil, err
	}
	finalCert, err := x509.ParseCertificate(derBytes)
	if err != nil {
		return nil, err
	}
	return &tls.Certificate{
		Certificate: [][]byte{derBytes},
		PrivateKey:  priv,
		Leaf:        finalCert,
	}, nil
}

// RotateRoot adds a new self-signed root certificate to the beginning of g.Roots,
// and removes any expired certificates.
func (g *GlobalHaState) RotateRoot(templateMaker func() (*x509.Certificate, error)) (err error) {
	// Generate an initial certificate root.
	var template *x509.Certificate
	template, err = templateMaker()
	if err != nil {
		return
	}
	var finalCert *tls.Certificate
	finalCert, err = makeCert(template, nil)
	if err != nil {
		return
	}
	res := Cert{Data: finalCert.Certificate, Key: finalCert.PrivateKey.(ed25519.PrivateKey), leaf: finalCert}
	if len(g.Roots) == 0 {
		g.Roots = []Cert{res}
	} else if g.Roots[len(g.Roots)-1].leaf.Leaf.NotAfter.After(time.Now()) {
		copy(g.Roots[1:], g.Roots)
		g.Roots[0] = res
	} else {
		g.Roots = append([]Cert{res}, g.Roots...)
	}
	return
}

// EndpointCert creates a short-lived per-node certificate that is signed by the most recent root certificate.

func (c *CurrentHAState) EndpointCert(templateMaker func() (*x509.Certificate, error)) (*tls.Certificate, error) {
	tmpl, err := templateMaker()
	if err != nil {
		return nil, err
	}
	addr, _, err := net.SplitHostPort(c.ConsensusAddr)
	if err != nil {
		return nil, err
	}
	tmpl.IPAddresses = []net.IP{net.ParseIP(addr)}
	return makeCert(tmpl, c.Roots[0].TLS())
}

// OurIp returns the IP address that should be set in an endpoint certificate for host validation.
func (c *CurrentHAState) OurIp() (string, error) {
	if !c.Enabled {
		return "", errors.New("HA not enabled")
	}
	if c.ConsensusAddr != "" {
		return c.VirtAddr, nil
	}
	if c.LoadBalanced {
		return c.VirtAddr, nil
	}
	ip, _, err := net.ParseCIDR(c.VirtAddr)
	return ip.String(), err
}

// Validate validates CurrentHAState to make sure is it sane.
func (cOpts *CurrentHAState) Validate() error {
	// Validate HA args.
	if !cOpts.Enabled {
		return nil
	}
	ourAddrs, err := net.InterfaceAddrs()
	if err != nil {
		return err
	}

	consensusAddr := ""
	consensusPort := ""

	if cOpts.ConsensusAddr != "" {
		consensusAddr, consensusPort, err = net.SplitHostPort(cOpts.ConsensusAddr)
		if err != nil {
			return err
		}
		cAddrOk := false
		if net.ParseIP(consensusAddr) == nil {
			return fmt.Errorf("Must specify an IP address for the consensus address")
		}
		for _, ourAddr := range ourAddrs {
			if ourAddr.(*net.IPNet).IP.String() == consensusAddr {
				cAddrOk = true
				break
			}
		}
		if !cAddrOk {
			return fmt.Errorf("Consensus address %s is not present on the system", consensusAddr)
		}
		portNo, _ := strconv.ParseInt(consensusPort, 10, 32)
		if portNo < 0 || portNo > 65536 {
			return fmt.Errorf("Consensus port %d is out of range", portNo)
		}
	}
	if cOpts.LoadBalanced {
		if cOpts.VirtAddr == "" {
			return fmt.Errorf("Error: HA must specify an address that eternal systems will see this system as")
		}
		if net.ParseIP(cOpts.VirtAddr) == nil {
			return fmt.Errorf("Error: Invalid HA address %s", cOpts.VirtAddr)
		}
		lbAddrOk := true
		for _, ourAddr := range ourAddrs {
			if ourAddr.String() == cOpts.VirtAddr {
				lbAddrOk = false
				break
			}
		}
		if !lbAddrOk {
			return fmt.Errorf("Virt address %s is present on the system, not permitted when load balanced", cOpts.VirtAddr)
		}
	} else {
		if cOpts.VirtAddr == "" {
			return fmt.Errorf("Error: HA must specify a VIP in CIDR format that DRP will move around")
		}
		// In HA mode with a VIP, force everything to talk to the VIP address.
		ip, cidr, err := net.ParseCIDR(cOpts.VirtAddr)
		if err != nil {
			return fmt.Errorf("Error: HA IP address %s not valid: %v", cOpts.VirtAddr, err)
		}
		if consensusAddr != "" && consensusAddr == ip.String() {
			return fmt.Errorf("Error: Consensus address %s cannot be the same as the HA virtual IP %s", consensusAddr, cOpts.VirtAddr)
		}
		cidr.IP = ip

		if cOpts.VirtInterface == "" {
			return fmt.Errorf("Error: HA must specify an interface for the VIP that DRP will move around")
		}

		if _, err = net.InterfaceByName(cOpts.VirtInterface); err != nil {
			return fmt.Errorf("Error: HA interface %s not found: %v", cOpts.VirtInterface, err)
		}
	}
	return nil
}

// GetHaState loads a serialized version of the CurrentHAState for a node from
// the directory passed in as Base.  It always attempts to read from a file named
// ha-state.json
func GetHaState(base string) (*CurrentHAState, error) {
	haStateFile := path.Join(base, "ha-state.json")
	stateFi, err := os.OpenFile(haStateFile, os.O_CREATE|os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}
	defer stateFi.Close()
	dec := json.NewDecoder(stateFi)
	st := &CurrentHAState{}
	if err = dec.Decode(st); err != nil || !st.Valid {
		st.ConsensusID = uuid.NewRandom()
		return st, SetHaState(base, st)
	}
	if err = st.FillTls(); err != nil {
		return nil, err
	}
	return st, nil
}

// SetHaState saves state into base/ha-state.json.  Any error in
// the process will leave the current file untouched.
func SetHaState(base string, state *CurrentHAState) error {
	haStateFile := path.Join(base, "ha-state.json")
	stateFi, err := ioutil.TempFile(base, ".ha-state-")
	if err != nil {
		return err
	}
	state.Valid = true
	defer os.Remove(stateFi.Name())
	defer stateFi.Close()
	stateFi.Truncate(0)
	enc := json.NewEncoder(stateFi)
	if err = enc.Encode(state); err != nil {
		return err
	}
	if err = stateFi.Sync(); err != nil {
		return err
	}
	return os.Rename(stateFi.Name(), haStateFile)
}

// NodeInfo is used to associate an URI to be used to talk to
// the dr-provision API for a particular Raft node.
type NodeInfo struct {
	NodeHaState
	// Offline indicates that leadership could not be transferred to
	// this node in the most recent election, despite it being the best candidate.
	// If a node is markes as Offline, it will stay that way until the node
	// updates its state with the current leader.
	Offline bool
	// LastArtifactCommitHandled tracks how up to date a node is compared to the current
	// cluster leader.  Artifact handling is allowed to happen asynchronusly from the rest
	// of Raft based replication due to the potentially large size of artifacts.  In the event
	// of a leadership transfer, the first node that is not Offline with the highest
	// LastArtifactCommitHandled value will be chosen as the new cluster leader.  If that
	// node is not also an Observer, it will become the new active dr-provision node.  If
	// it is an Observer, it will wait for one of the operating Passive nodes to catch up to it,
	// and then transfer leadership to it.
	LastArtifactCommitHandled uint64
}

// ClusterState is the overall state of a consensus cluster.
type ClusterState struct {
	GlobalHaState
	Nodes []NodeInfo
}
